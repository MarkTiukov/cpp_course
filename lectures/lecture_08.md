# Лекция 8

## 3. Compound types

### 4. Функции

#### 3. Pointers to functions

Давайте сначала поймем, что мы хотим научиться делать. Рассмотрим простой, но очень практичный пример.
Мы имеем функцию, которая сортирует массив (в `stl` это функция `std::sort`). По умолчанию она сортирует элементы (допустим числа) по неубыванию. 
А если мы хотим наоборот, по невозрастанию? Писать целую новую функцию, хотя вся разница — это вместо `<` использовать `>`?? Надеюсь, всем читателям на данном этапе уже понятно, что это плохой подход.
Лучше научиться передавать в функцию аргумент, который будет сравнивать за нас два элемента и говорить, какой из них должен идти левее в итоговом массиве. И эту проблему мы как раз и можем решить с помощью указателей на функцию!

*Spoiler:* в дальнейшем мы научимся это решать более приятным способом, а пока придется потерпеть

```C++
bool cmp(int a, int b) { // функция, с помощью которой мы хотим сравнивать элементы
    return x > y;
}

int main() {
    int a[5] = {1, 2, 3, 4, 5};
    std::sort(a, a + 5, &cmp); // знакомый синтаксис, не правда ли?
}
```

А как же создать объект этого указателя, какой у него тип? ~~Всё просто~~

```C++
bool (*p)(int, int) = &cmp;
```

Здесь р — указатель на функцию, которая принимает два int'а, а возвращает bool

Вот еще пара примеров, чтобы продемонстрировать другие возможности:

```C++
void f(int);
void f(double);
void g(int);

void (*p)(int) = &f; // можно писать просто f, без &

p(5); // вызов функции f

p = &g; // ОК, потому что g тоже принимает int и возвращает void
```

**Note:** если функция объявлена, но не определена, то создание указателя на нее — СE

#### 4. Inline functions

```C++
inline void f();
```

Ключевое слово `inline` говорит компилятору, что данную функцию не надо вызывать, надо вставить код ее тела прямо в те места, где она вызывается

**Note:** на самом деле в современных плюсах использование данного ключевого слова *почти* бесполезно, благодаря продвинутым компиляторам, которые за нас сделают все подобные оптимизации

### 5. References (Ссылки)

#### 0. Мотивация

Можно сказать очень просто: указатели зло, хочется что-то удобнее в обращении, хотим создавать объект, *ссылающийся* на другой, без создания копии

#### 1. Базовый синтаксис

```C++
std::vector<int> v{1, 2, 3};
std::vector<int>& v2 = v;
```

`v2` — это **ссылка** на объект `v`. С момента создания она будет (почти) всегда вести себя как объект `v`, в частности `&v2 == &v1` и
`void f(vector<int>&)` не является перегрузкой функции `void f(vector<int>)`
(будет СЕ, если написать оба варианта).
Почему почти? — есть способ различить эти два объекта (`decltype`), но об этом мы поговорим потом

При объявлении ссылки её **необходимо** **проинициализировать** через lvalue. Поменять объект, на который она ссылается нельзя

#### 2. Что позволяет делать ссылка?

```C++
int& f(int& x, int n = 1) {
    x += n;
    return x;
}

int a = 7;
f(a); // a == 8
f(a) = 20; // a == 20
++f(a) = 0; // a = 0
```

А главное, мы можем еще раз усовершенствовать наш `swap`=)

```C++
void swap(int& x, int& y) {
    int tmp = x; // создаем копию
    x = y;
    y = tmp;
}
```

#### 3. Dangling reference

Рассмотрим следующий код
(по сути взяли функцию выше, но ошиблись в сигнатуре и забыли `&`):

```C++
int& g(int x) {
    ++x;
    return x;
}

int main() {
    int a = 7;
    g(7) = 10; // а всё, UB
}
```

Откуда здесь UB? Всё просто. Мы возвращаемся ссылку на инт. А что за объект, на который мы ссылаемся? — Да это же локальная (для функции `g`) переменная `x`.
То есть мы ссылаемся на объект, который после завершения вызова `g(7)` должен вообще-то разрушится

**Важно:** объект уничтожается, когда должен разрушиться его первоначальный экземпляр, без учета ссылок на него

### 6. Константы


```C++
const int a = 5;
```

`const int` — новый тип, который по сути является обрезанным старым (не доступны операции, изменяющие объект)

```C++
const int* p = &a; // указатель на const int
++p;  // OK
++*p; // CE, потому что *p это const int, а инкремент к const int применять нельзя
```

При этом:

```C++
int b = 10;
int* const pp = &b; // константный указатель
++*pp; // OK, тк разыменование константы можно, а под ним будет int обычный
++pp; // CE, тк p нельзя изменять
```

То есть в случае константного указателя мы получаем фиксированный адресс в памяти, который нельзя поменять, но при это указывать эта память может и на изменяемый объект

Рассмотрим еще несколько "веселых" примеров:

```C++
const int* const ppp = pp;
```

Здесь происходит неявный каст (навешивается `const` сверху на тип)

```C++
int* const q = ppp; // CE: нелья отбросить внутренний конст
const int* qq = ppp; // ОК (создается копия, которая копирует адресс под указателем)
```

На указатели посмотрели, а что там с ссылка? А вот что:

```C++
int a = 5;
int& r = a; // обычная ссылка
const int& cr = a; // заводим константную ссылку
```

В отличие от указателей, со ссылками всё просто: в отличие от указателей, тут всё просто, у нас нет каких-то разночтений, существует только константная ссылка `const int&` (**никакого `int& const` !!!**).
Что же это значит?

**Константная ссылка == ссылка на константу**, то есть как обычная ссылка, но нельзя применять операции, меняющие объект

Интересно следующие:

```C++
++r;
std::cout << cr; // 6
```

Почему же изменился `cr`, если изменять объект нельзя? Потому что операции применена не над `cr`, а над `r`, просто ссылаются они на один и тот же объект. 

Хорошей аналогией из реальной жизни будет работа с документмо в гугл диске:
Вы можете пошарить ссылку на чтение (это будет аналог нашей конст-ссылки). Безусловно, вы всё ещё можете менять документ, потому что вы обращается по ссылке, разрешающей редактирование. А вот те, кто смотрит по ссылке, не могут редактировать, хотя они видят все ваши изменения!

Ну и очевидный, но важный момент:

```C++
int& rr = cr; // CE, мы не можем просто так сбросить const
```

### 7. Аргументы в функцию

Пункт немного не про compound types, но самое время углубить наши знания про функции (хотя всё еще не до конца =), применив новые знания про ссылки и константы

Главный вопрос данного пункта: как лучше передавать аргументы?

И так, у нас получается следующий список возможных вариант, как передать объект:

1. по значению: `void f(int);`
1. по ссылке: `void f(int&);`
1. по конст-ссылке: `void f(const int&);`

*Замечание:* указатели тут не рассматриваются, потому что это отдельные случаи, не трубующие пояснений

Самый редкий случай — передача по значению. Используется редко, потому что в таком случае
будет создаваться копия объекта (что зачастую слишком дорогая, долгая, операция). Исключение составляют случаи, когда мы хотим изменять внутри объект, но не видеть изменений снаружи функции, то есть придется создавать копию в любом случае, даже если передали по ссылке, и базовые типы (int, double, char, bool),
оптимизация которых может быть даже дольше и лучше передать по копии

Как выбрать между оставшимися пунктами? Легко: надо изменять объект и видеть эти изменения снаружи? — вам нужна передача по ссылке, иначе по конст-ссылке

*Замечание:* отмечу, что можно написать перегрузку функции для ссылки и конст-ссылки, то есть:

```C++
void f(int&);
void f(const int&);
```

Ещё один занимательный факт: если функция принимает конст-ссылку, то можно туда передать и rvalue (шок-контент). Это явление называется **продление жизни**
