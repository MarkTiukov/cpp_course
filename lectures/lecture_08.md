# Лекция 8

## 3. Compound types

### 4. Функции

В этом пункте мы немного расширим наши знания о функциях в С++

#### 0. Напоминание

В общем виде (пока) мы можем описать функцию следующим видом:

```
return-type name(Type1 arg1, Type2 arg2) { // любое количество аргументов
    // body
}
```

#### 1. Trailing argument default value

Часто возникают ситуации, когда мы хотим написать какую-то функцию с таким аргументом X,
который в большинстве случаев имеет одно и то же значение и лишь в редких случаях будет принимать что-то иное.
То есть мы хотим, чтобы этот аргумент имел какое-то дефолтное значение.
И в С++ есть способ это задать!

```C++
void f(int x, int y = 1);
```

Такую функцию можно вызывать несколькими способами:

```C++
f(2, 3); // '= 1' для y игноритуется, то есть x=2, y=3
f(2); // x == 2, y == 1
```

Безусловно таких аргументов может быть сколько угодно,
но если какой-то аргумент имеет значение по умолчанию, то все следующие аргументы должны тоже его иметь!

#### 2. Function overloading (перегрузка функций)

В С++ у нас есть такая прекрасная возможность как перегрузка функций.
Мы можем написать несколько функций с одним именем и в одном скоупе, но с разными сигнатурами
(напомню, что return-type не входит в сигнатуру)

Например:

```C++
double f(int);
double f(double);
```

Таким образом можно в одну функцию передавать аргументы разных типов

Как же тогда компилятор выбирает правильную функцию?

Полный список можно найти на [сппреференс](https://en.cppreference.com/w/cpp/language/overload_resolution), но главное усвоить простые три пункта:

1. Точно совпадение всегда лучше
1. После этого promotion cast
1. Если через promotion не получается, то идут конверсии

**Важно:** если для компилятора несколько перегрузок одинаковы (равнозначны), то он не может выбрать между ними и будет CE

```C++
void f(int);
void f(float);

int main() {
    f(7.0); // CE: double->int и double->float равнозначны для компилятора
}
```

#### 3. Pointers to functions

Давайте сначала поймем, что мы хотим научиться делать. Рассмотрим простой, но очень практичный пример.
Мы имеем функцию, которая сортирует массив (в `stl` это функция `std::sort`). По умолчанию она сортирует элементы (допустим числа) по неубыванию. 
А если мы хотим наоборот, по невозрастанию? Писать целую новую функцию, хотя вся разница — это вместо `<` использовать `>`?? Надеюсь, всем читателям на данном этапе уже понятно, что это плохой подход.
Лучше научиться передавать в функцию аргумент, который будет сравнивать за нас два элемента и говорить, какой из них должен идти левее в итоговом массиве. И эту проблему мы как раз и можем решить с помощью указателей на функцию!

*Spoiler:* в дальнейшем мы научимся это решать более приятным способом, а пока придется потерпеть

```C++
bool cmp(int a, int b) { // функция, с помощью которой мы хотим сравнивать элементы
    return x > y;
}

int main() {
    int a[5] = {1, 2, 3, 4, 5};
    std::sort(a, a + 5, &cmp); // знакомый синтаксис, не правда ли?
}
```

А как же создать объект этого указателя, какой у него тип? ~~Всё просто~~

```C++
bool (*p)(int, int) = &cmp;
```

Здесь р — указатель на функцию, которая принимает два int'а, а возвращает bool

Вот еще пара примеров, чтобы продемонстрировать другие возможности:

```C++
void f(int);
void f(double);
void g(int);

void (*p)(int) = &f; // можно писать просто f, без &

p(5); // вызов функции f

p = &g; // ОК, потому что g тоже принимает int и возвращает void
```

**Note:** если функция объявлена, но не определена, то создание указателя на нее — СE

#### 4. Inline functions

```C++
inline void f();
```

Ключевое слово `inline` говорит компилятору, что данную функцию не надо вызывать, надо вставить код ее тела прямо в те места, где она вызывается

**Note:** на самом деле в современных плюсах использование данного ключевого слова *почти* бесполезно, благодаря продвинутым компиляторам, которые за нас сделают все подобные оптимизации
