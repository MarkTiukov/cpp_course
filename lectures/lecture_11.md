# Лекция 11

## 4. ООП

### 1. Classes and Structures

#### 11. Const objects and methods

Наконец-то мы можем обсудить, что такое константность в C++.
На самом деле все очень просто: константный объект — это объект с обрезанным функционалом.
То есть это объект, у которого можно вызывать лишь подножество методов (и у его полей аналогично).
Методы, которые мы хотим разрешить вызывать надо помечать ключевым словом `const` (является частью сигнатуры, то есть можно перегружать)

```C++
struct S {
    int x = 7;

    void f() {
        std::cout << "not const" << std::endl;
    }

    void f() const {
        // x++; // тут будет CE, тк у int оператор ++ не const
        std::cout << "const" << x << std::endl; // тут ОК, тк оператор << const
    }

};

int main() {
    const S s;
    s.f(); // const
    S ss;
    ss.f(); // not const
}

```

Но встречаются ситуации, когда какое-то поле нужно все-таки изменять.
Например, это внутренний счетчик количества созданных объектов или вызова какой-то функции(для логов/дебага).
В таком случае это поле можно пометить ключевым словом `mutable`

```C++
struct S {
    int x = 7;

    void f() const {
        x++; // теперь ОК
        std::cout << x << std::endl;
    }
};
```

На практике не принято разбрасываться `mutable`. Важно понимать, что у const объекта есть "контракт" — не подвержен **внешним** изменениям

Теперь давайте подумаем, как бы выглядел оператор [] у String.
Раньше мы бы его реализовали так:

```C++
char& operator[](size_t ind) {
    return str[ind];
}
```

Но теперь мы понимаем, что он должен быть помечен `const`:

```C++
char& operator[](size_t int) const {
    return str[ind];
}
```

А вот теперь случилось ужасное. Мы разрешили менять символы у константной строки :с
Как так вышло, почему нет CE?

Ответ на самом деле простой: указатели и ссылки (которые под капотом тоже указатели в таком контексте) будут константными, а вот на данные под ними это свойство уже не распространяется.

