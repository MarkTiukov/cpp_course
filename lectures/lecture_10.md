# Лекция 10

## 3. Compound types

### 8. Приведение типов

Раз мы уже познакомились с кучей новых типов (любой тип —> ссылка на любой тип -> конст-ссылка на этот тип), то пора и научиться приводить эти типы друг к другу (мы уже смотрели, что можно неявно навесить `const` на ссылку, но можно и много чего другого!)

Сейчас мы пройдем 4 вида кастов, позже познакомися еще с одним

#### 1. Static cast

Этот каст позволяет производить известные компилятору касты, иначе мы получим ошибку компиляции

```C++
int a = 7;
double b = static_cast<int>(a);
```

*Спойлер:* да, мы научимся обучать компилятор правилам каста :)

Данный каст является наиболее безопасный и лучше всего никогда не использовать другие!

#### 2. Reinterpet cast

Краткое описание: любой тип к любому, но применим только над ссылками и указателями

```C++
int a = 7;
double d = *reinterpet_cast<double*>(&a);
```

то есть мы переводим `int*` в `double*` и разыменовываем.
Данное действие на самом деле UB, потому что `reinterpet_cast` берет биты одного объекта и начинает их *интерпретировать* как биты другого. А мы помним, что инты и даблы совершенно иначе воспринимают свои биты (см "как храниться double в памяти)

Аналогично можно со ссылками, но уже без дополнительных операций (взятия адресса и разыменования):

```C++
double& dd = reinterpet_cast<double&>(a);
```

#### 3. Const cast

1. Позволяет навесить конст (явно):

```C++
int a = 7;

void f(int&);
void f(const int&);

f(const_cast<const int&>(a)); // вызовет от const int&
```

2. Позволяет убрать конст, но по сути это не UB только если вы точно знаете, что переданный объект когда ссылался не на const тип!

#### 4. C-style cast

Самый ужасный каст...

Производит предыдущие касты в следующей последовательности:

const -> static -> static + const -> reinterpret -> reinterpret + const

И только в случае фейлов всех таких комбинаций вы получите CE

## 4. ООП
