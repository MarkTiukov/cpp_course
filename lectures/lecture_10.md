# Лекция 10

## 4. ООП

### 1. Classes and Structures

#### 3. Инкапсуляция

**Инкапсуляция** — механизм языка, ограничивающий доступ одних компонентов программы к другим.

#### 4. Public, private

Все объявления внутри структуры/класса относятся к одному из двух видов доступа (на самом деле трех, но пока третий варинат мы не рассматриваем): public или private.

Как это выглядит:

```C++
struct S {
public:
    // все, что объявляем тут, будет `публичным`
private:
    // все, что объявляем тут, будет `приватным`
};
```

Можно сколько угодно раз указывать public/private, в любом порядке.

Что же это значит? К публичным объектам можно обращаться в любой ситуации, а вот к приватным доступ имеет только сам класс. То есть

```C++
struct S {
public:
    int a;
private:
    int b;

public:
    void f() {
        std::cout << a << b << std::endl; // OK
    }
};

int main() {
    S s;
    std::cout << s.a << std::endl; // OK
    std::cout << s.b << std::endl; // CE: no access to s.b (b is private)
}
```

Здесь мы встречаемся с различием между `struct` и `class`: у структуры все поля по умолчанию публичные, у класса — приватные

Важный момент, касающийся методов: сначала выполняется перегрузка функций, а только после проверяется доступность

```C++
class S {
private:
    void f(int);
public:
    void f(double);
};

int main() {
    S s;
    s.f(0); // CE
}
```

В примере выше правила перегрузки выбирают вариант `void f(int)` (потому что полное совпадение),
но эта версия является приватной, а значит у нас будет CE из-за отсутствия доступа

#### 5. friend

Ключевое слово `friend` позволяет добавить исключение в ограничении доступности.
Для этого внутри структуры/класса, нужно указать, для какого объекта мы добавляем исключение (мб как функция, так и класс/структура).
Это будет означать, что этот объект может обращаться к приватным данным.
Данное отношение 'дружбы' не является ни симметричным, ни транзитивным!

```C++
class C {
private:
    int x;

    friend int main();
    friend int g();
    friend struct S;
};

int g() {
    return C().x; // OK
}

int main() {
    C c;
    c.x; // OK
}
```

#### 6. Constructors and destructors

Возможность задавать значения полей через обращение к каждому отдельно или через дефолтные значения — не очень удобный механизм.
Поэтому есть механизм конструкторов. Грубо говоря, это специальный вид методов, которые регулируют алгоритм создания объекта

```C++
class Complex {
    double r = 0.5;
    double i;

public:

    Complex(double r, double ii) {
        this->r = r;
        i = ii;
        std::cout << "constructor" << std::endl;
    }

};

int main() {
    Complex cc(0.3, 2.4); // вызов конструктора
}
```

Основная цель конструктора — проинициализировать поля. На самом деле поля инициализируются в момент вызова конструктора, но **до** его тела. То есть в примере выше мы на самом деле просто меняем значение поля. Чтобы именно проинициализировать поля, нужно воспользоваться конструкцией *initializer list*. 

```C++
Complex(double r, double ii) : r(r), i(ii) // initializer list
{ 
    std::cout << "constructor" << std::endl;
}
```

Замечание 1: конструктор над объектом можно вызвать **ровно 1 раз**, а порядок перечисления полей в списке инициализации должен быть в том же порядке, что и при объявлении

Замечание 2: поля, тип которых либо ссылка, либо константа должны быть проинициализированы до тела конструктора

Замечание 3: если нет ни одного объявленного конструктора, то компилятор создаст конструктор по умолчанию (без аргументов). Иначе можно попросить компилятор сделать это с помощью `= default`:

```C++
struct S {
    S() = default; // инициализация полей значениями по умолчанию
    S(int) {}
};
```

Замечание 4: противоположно конструкции `= default` можно прописать `= delete`, чтобы компилятор не создавал данного метода (+ это уберет возможные неявные касты для конкретного случая)

Пример полезного применения конструктора: класс String, в конструкторе которого выделяем динамическую память

```C++
class String {
    char* str;
    size_t size;

public:
    String() = default;
    String(size_t n, char c)
        : str(new char[n])
        , size(n) 
    {
        memset(str, c, n); // ccccccccccccccc | n раз
    }

};
```

Чтобы так же спрятать внутрь освобождение памяти (а самое главное — не забыть это сделать), есть механизм 'деструктор':

```C++
~String() {
    delete[] str;
}
```

Порядок действий над объектом получается следующий:

1. Инициализация полей в порядке перечисления в классе/структуре
1. Тело конструктора
1. Пользовательские действия над объектом
1. Тело деструктора
1. Уничтожение полей в обратном порядке

#### 7. Copy-constructor

Это конструктор, который позволяет создать объект из другого объекта этого же типа.

Важно понимать, что если мы просто скопируем указатель, например, то легко получить double-free ошибку. Поэтому правильный копи-конструктор для стринга:

```C++
String(const String& s) : str(new char[s.size]), size(s.size) {
    memcpy(str, s.str, size);
}
```

Обратите внимание, что копи-конструктор не может принимать объект по копии (норм по ссылке или указателю).

#### 8. Делигирующий конструктор

Чтобы не дублировать логику, прописанную в другом конструкторе:

```C++
struct S {
    int a;
    S(int, double) { .... }
    S(int a): S(a, 0.5) { .... } // <- делегация
};
```

#### 9. Copy assignment operator (оператор =)

Данный оператор позволяет скопировать значение объекта вместо уже созданного объекта. То есть похоже на конструктор копирования, но выполняется над уже инициализированным.
Поэтому при его реализации важно следить, не забыли ли мы очистить замещаемые ресурсы

```C++
    String& operator=(const String& other) {
        delete[] str; // !!!
        str = new char[other.size]; // потому что после delete
        size = other.size;
        memcpy(str, other.str, size);
        return *this;
    }
```

Внимательный читатель может заметить, что данная реализация копирует много логики из конструктора копирования (+ опять приходится следить за ресурсами). Для того, чтобы избежать этого можно воспользоваться Copy-and-Swap идиомой.
Смысл очень прост. Нам понадобиться доопределить метод `Swap(S& other)`, который меняет два объекта местами, после чего в операторе создаем временный объект, меняем с ним то, что хотим скопировать и всё!
Кстати, данная идиома нам решает очень важный кейс: теперь мы можем скопировать сами себя! (подумайте, почему раньше не могли и что поменялось)

```C++
void Swap(String& s) {
    std::swap(str, s.str);
    std::swap(size, s.size);
}

String& operator=(const String& other) {
    String copy = other;
    Swap(copy);
    return *this;
}
```

#### 10. The rule of three

Простое мнемоническое правило в C++, которое в 10/10 случаев улучшает качество и надежность вашего кода. Если у вас реализовано один из следующих пунктов, реализуйте и остальные:

* destructor
* copy constructor
* сopy assignment operator
