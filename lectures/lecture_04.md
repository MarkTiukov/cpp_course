# Лекция 4

#### 2. Приведение типов

1. **Integer promotion**: если операция производится над разными типами, где один "больше" другого, то меньший приводится к большему и этот тип будет итоговым типом выражения. Например, `int -> long long` или `short -> int`. Неприятным случаем является приведение знакового инта к беззнаковому, потому что биты просто начинают интерпретироваться иначе.
1. Аналогично **Floating point promotion**
1. char <-> int
1. bool <-> int
1. Приведение большего к меньшему возможно: double->int отбрасывает дробную часть. НО такое лучше не делать :)

#### 3. Литералы

Для всех основных типов можно использовать различные форматированные строковые константы или шестнадцатиричное представление значений:
    
    * 7    | int 
    * 7u   | unsigned int
    * 7.0  | double
    * 7.0f | float
    * 'a'  | char
    * 07   | int, но в 8-ричной системе
    * 0x2a | int, но в 16-ричной системе 
    * u - unsingned, l - long, ll - long long

#### 4. Понятие идентификатора

https://en.cppreference.com/w/cpp/language/identifiers

### 5. Стандартные контейнеры

#### 1. std::string

Объект, для удобной работы со строками.

```C++
std::string s = "abcdef";
s[1]; // 'b' (нумерация с 0)
s.size(); // 6
s.length(); // 6
s.substr(3, 2); // "de"
s += 'g';
```

#### 2. std::vector

Контейнер для хранения неопределенного количества объектов (одного типа)

```C++
std::vector<int> v; // пустой
std::vector<int> v(10); // изначальный размер
v[3]; // обращение к 4му элементу (обращаться за пределы размера нельзя)
v.size(); // размер вектора
v.resize(20); // изменение размера
v.push_back(3); // добавление элемента в конец (с увеличением размера)
v.pop_back(); // удаление последнего элемента
```

### 6. Expressions and operators

Неформально, выражение -- это комбинация литералов, идентификаторов и операторов. Для формального определения необходимо перечислить всю грамматику языка, чем мы заниматься не будем

#### 1. Операторы в C++:

1. Арифметические: + - * / %
1. Побитовые: & | ^ ~ << >>
1. Сравнения: == != < > <= >= <=> (since C++20, spaceship operator)
1. Логические операторы: && || !

    **!** Вычисления ленивые
1. Инкремент и декремент: ++ --
1. Присваивание (+ составное):  =  +=  -=  *=  /=  %=  &=  |=  ^=  <<=  >>=
    
    **!** Эти операторы возвращают результат операции, то есть можно писать `a = b = c`. Вычисляются они в таком случае справа налево, то есть это эквиваленто `a = (b = c)`.
    
    "=" не всегда является оператором. Например в строчке `int x = 5;` "=" это не оператор.

    Начиная с C++17 гарантируется что правая часть от оператора `=` вычисляется первой (`++x = x++`).
1. `sizeof` (оператор из языка Си): возвращает количество байт, которое занимает объект в памяти. 

    ```C++
        sizeof(int) // 4
        int x;
        sizeof(x) // 4
    ```

    Важно понимать, что `sizeof` вычисляет ответ на этапе компиляция и это всегда константа. Он не знает, сколько динамической памяти будет использовано. То есть `sizeof` от вектора не зависит от количества элементов внутри. Также это значит, что результат выражения, переданного в `sizeof` не вычисляется: `sizeof(x++)` x не изменяет.

1. Тернарный оператор: `condition ? expression_if_true : expression_if_false`
1. Оператор запятая: `expr1, expr2`: вычисляет `expr1`, затем `expr2` (посследовательность гарантирована) и возвращает результат `expr2`
1. Вызов функции (оператор круглые скобочки)
1. subscript operator (квадратные скобочки)

#### 2. Приоритеты операторов

https://en.cppreference.com/w/cpp/language/operator_precedence
