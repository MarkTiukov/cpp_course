# Лекция 6

## 3. ???

### 1. Указатели

#### 0. Мотивация

Как написать функцию swap, которая принимает на вход две переменные одного типа (например, `int`), а в результате их значения меняются местами?

```C++
void swap(int a, int b) {
    int tmp = b;
    b = a;
    a = tmp;
}
```

<details>
<summary>Выполняет ли поставленную задачу код выше?</summary>
Нет, потому что a и b — копии переданных переменных

То есть нам нужно каким-то образом передавать первоначальные переменные
</details>

#### 1. Variable address

```C++
int x = 7;
std::cout << &x; // выводится целое число в 16-ричной системе 
```

Данное число — адресс переменной в памяти

#### 2. Pointer syntaxis

```C++
int x = 7;
int* p = &x; // <- объявление указателя
```

**Указатель** — новый тип объектов. Записывается как `объявленный_тип*` (здесь `*` является частью названия типа). Для чего нужен данный тип? Для обращение к памяти напрямую

Так что же такое `&x`? В данном контексте `&` — это унарный (один аргумент) оператор, который принмиает на вход идентификатор, а на выходе выдает адресс этой переменной. То есть можно формально записать: `&: T -> T*`

**!** результат данного оператора — rvalue, но выражение, которое оператор принимает на вход должно быть lvalue. То есть:

```C++
int* p = &5; // CE
int* p = &(++a); // OK
int* p = &(a++); // CE
```

Что же можно делать с указателями? 

#### 3. Dereferencing

```C++
int x = 7;
int* p = &x;
std::cout << *p; // -> 7
x = 10;
std::cout << *p; // -> 10
```

В коде выше `*p` — унарный оператор *разыменования*. Он принимает на вход указатель, а на выходе возвращает ту самую переменную, на которую указывает (не копию, а именно переменную; более формально мы научимся описывать этот тип чуть позже). То есть `*p` — это lvalue-выражение. Это позволяет нам писать и подобные конструкции:

```C++
int x = 7;
int* p = &x;
*p = 5;
std::cout << x; // -> 5
```


