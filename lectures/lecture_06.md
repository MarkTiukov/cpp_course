# Лекция 6

## 3. Compound types

### 1. Указатели

#### 0. Мотивация

Как написать функцию swap, которая принимает на вход две переменные одного типа (например, `int`), а в результате их значения меняются местами?

```C++
void swap(int a, int b) {
    int tmp = b;
    b = a;
    a = tmp;
}
```

<details>
<summary>Выполняет ли поставленную задачу код выше?</summary>
Нет, потому что a и b — копии переданных переменных

То есть нам нужно каким-то образом передавать первоначальные переменные
</details>

#### 1. Variable address

```C++
int x = 7;
std::cout << &x; // выводится целое число в 16-ричной системе 
```

Данное число — адресс переменной в памяти

#### 2. Pointer syntaxis

```C++
int x = 7;
int* p = &x; // <- объявление указателя
```

**Указатель** — новый тип объектов. Записывается как `объявленный_тип*` (здесь `*` является частью названия типа). Для чего нужен данный тип? Для обращение к памяти напрямую

Так что же такое `&x`? В данном контексте `&` — это унарный (один аргумент) оператор, который принмиает на вход идентификатор, а на выходе выдает адресс этой переменной. То есть можно формально записать: `&: T -> T*`

**!** результат данного оператора — rvalue, но выражение, которое оператор принимает на вход должно быть lvalue. То есть:

```C++
int* p = &5; // CE
int* p = &(++a); // OK
int* p = &(a++); // CE
```

Что же можно делать с указателями? 

#### 3. Dereferencing

```C++
int x = 7;
int* p = &x;
std::cout << *p; // -> 7
x = 10;
std::cout << *p; // -> 10
```

В коде выше `*p` — унарный оператор *разыменования*. Он принимает на вход указатель, а на выходе возвращает ту самую переменную, на которую указывает (не копию, а именно переменную; более формально мы научимся описывать этот тип чуть позже). То есть `*p` — это lvalue-выражение. Это позволяет нам писать и подобные конструкции:

```C++
int x = 7;
int* p = &x;
*p = 5;
std::cout << x; // -> 5
```

Отметим, что указатель — переменная, а значит мы можем получить указатель на другой указатель =)

```C++
int x = 9;
int* p = &x;
int** pp = &p;
std::cout << pp << std::endl; // -> адрес переменной p
std::cout << *pp << std::endl; // -> адрес переменной х
std::cout << **pp << std::endl; // -> значение переменной x 
// и так можно продолжать дальше...
```

Теперь давайте напишем *рабочую* функцию swap

```C++
void swap(int* a, int* b) {
    int tmp = *b;
    *b = *a;
    *a = tmp;
}
```

#### 4. Прочие операции с указателями

1. `T* + n` — сдвигает указатель на `sizeof(T) * n` байт
1. **Пост(пре-)фиксный декремент/инкремент** — сдвиг на +-sizeof(T) байт 
1. `T* - T*` — разница двух указателей на **одинаковый** тип возврщает количество шаг между двумя указателями
1. Сравнение двух указателей

#### 5. Особые указатели

**void*** — указатель на любой тип данных или "сырую память"

**nullptr** — указатель на "ничто". Можно использовать как нулевое значение и т.п. В языке Си есть значение NULL, но для С++ лучше использовать nullptr (как минимум, потому что у nullptr есть тип — nullptr_t)

### 2. Устройство памяти

**DISCLAIMER:** В этом разделе мы рассмотрим, как устроена память, но лишь в первом приближении. Многое остается за скоупом нашего курса, а в некоторых местах будут упрощения. 

#### 1. Общая картина (data, text, stack)

При запуске программы в [RAM](https://en.wikipedia.org/wiki/Random-access_memory) выделяется блок памяти, состоящий из трех частей: data, text и stack. Ниже мы поймем, что хранится в каждом из этих блоков, но важно, что размер каждого блока известен на момент конца компиляции

1. **Text** — здесь хранится бинарный код нашей программы
1. **Data** — здесь хранятся все глобальные переменные, например. На самом деле, тут еще ооочень много, что хранится, и мы постепенно узнаем некоторые объекты, которые тут хранятся. Размер высчитывается на этапе компиляции и указывается в бинарном файле запуска
1. **Stack** — здесь по болейшей части хранятся локальные переменные. Размер стека определяется операционной системой (обычно 4МБ или чаще всего 8МБ). Поэтому большое (огромное) количество переменных может привести к ошибке `StackOverflow`. Самое интересное, что на стек также кладется указатель возврата, при вызове какой-то функции. Поэтому бесконечная рекурсия также приводит к данной ошибке, даже если функция не создает каких-либо новых переменных

Переменную внутри функции можно объявить как `static` (например, `static int x;`). Это значит, что переменная будет одна и та же для всех вызовов данной функции. В таком случае она хранится в Data

#### 2. Segmentation fault

Ошибка, когда мы обращаемся не к "своей" памяти, то есть ОС убивает нас при обращению к памяти, которая не выделена под нашу программу

#### 3. Динамическая память

А как же жить, если программа не может узнать, сколько объектов ей нужно хранить на момент компиляции и запуска (например, это зависит от ввода от пользователя или количества клиентов нашего сервиса)?

На помощь приходит **динамическая память**. То есть память, которая выделяется под нашу программу в RAM через отдельный запрос во время работы программы. Как же это сделать? — нам поможет оператор `new`, который возвращает указатель на выделенную память.

```C++
int* p = new int; // просим выделить память под объект типа int
```

Можно сразу положить какое-то значение в эту память:

```C++
int* p = new int(7);
```

Важно, что нам крайне желательно "освобождать" выделенную память обратно операционной системе, когда она нам больше не нужна. Иначе будет **Memory Leak** (утечка памяти). Делается это с помощью оператора `delete`:

```C++
delete p;
```
