# Лекция 9

## 3. Compound types

### 8. Приведение типов

Раз мы уже познакомились с кучей новых типов (любой тип —> ссылка на любой тип -> конст-ссылка на этот тип), то пора и научиться приводить эти типы друг к другу (мы уже смотрели, что можно неявно навесить `const` на ссылку, но можно и много чего другого!)

Сейчас мы пройдем 4 вида кастов, позже познакомися еще с одним

#### 1. Static cast

Этот каст позволяет производить известные компилятору касты, иначе мы получим ошибку компиляции

```C++
int a = 7;
double b = static_cast<int>(a);
```

*Спойлер:* да, мы научимся обучать компилятор правилам каста :)

Данный каст является наиболее безопасный и лучше всего никогда не использовать другие!

#### 2. Reinterpet cast

Краткое описание: любой тип к любому, но применим только над ссылками и указателями

```C++
int a = 7;
double d = *reinterpet_cast<double*>(&a);
```

то есть мы переводим `int*` в `double*` и разыменовываем.
Данное действие на самом деле UB, потому что `reinterpet_cast` берет биты одного объекта и начинает их *интерпретировать* как биты другого. А мы помним, что инты и даблы совершенно иначе воспринимают свои биты (см "как храниться double в памяти)

Аналогично можно со ссылками, но уже без дополнительных операций (взятия адресса и разыменования):

```C++
double& dd = reinterpet_cast<double&>(a);
```

#### 3. Const cast

1. Позволяет навесить конст (явно):

```C++
int a = 7;

void f(int&);
void f(const int&);

f(const_cast<const int&>(a)); // вызовет от const int&
```

2. Позволяет убрать конст, но по сути это не UB только если вы точно знаете, что переданный объект когда ссылался не на const тип!

#### 4. C-style cast

Самый ужасный каст...

Производит предыдущие касты в следующей последовательности:

const -> static -> static + const -> reinterpret -> reinterpret + const

И только в случае фейлов всех таких комбинаций вы получите CE

## 4. ООП

### 1. Classes and Structures

**!DISCLAIMER:**  пока не будет сказано обратного, считаем структуру и класс синонимами. Для удобства и отсутсвия проблем с компиляцией в примерах будут в основном структуры, но все свойства так же распространяются и на классы

#### 1. Basics

```C++
struct S {}; // объявляем структуру
class C {};  // объявляем класс
```

Что же такое структура и класс? Вкратце, это новый тип данных, который мы объявляем для нашей программы.
Внутри структуры и классы могут содержать какие-то данные (переменные),
а так же они имеют какие-то свойства, которые так же мы будем определять, на чем и строится ООП.

В примере выше мы объявляем структуру S и класс C. То есть `struct` и `class` — ключевые слова, а `S` и `C` — идентификаторы (большинство кодстайлов говорят использовать в данном случае PascalCase)

Чтобы создать объект нашего нового типа, мы будем пользоваться уже знакомым синтаксисом, заменив базовый тип на название структуры/класса:

```C++
struct S {};

int main() {
  S s; // создаем переменную s с типом S
}
```

Внутри структы/класса можно также объявлять переменные (будем называть такие **поля**) и функции (будем называть такие **методами**). При этом эти функции и переменные будут привязаны к конкретному объекту этого типа

```C++
struct S {
  int x;
  double y;
  char z;

  std::string f() { return "Hello, world!"; }
};
```

Чтобы обратиться к этим полям/методам, можно воспользоваться оператором "точка":

```C++
S s;
s.x = 1;
s.y = 0.7;
s.z = 'a';

s.f();

std::cout << s.x << " " << s.y << " " << s.z << std::endl;

S s2;
s2.x = 3;
std::cout << s.x << " " << s2.x << std::endl; // вывод: "1 3", то есть значения переменных в `s` не равны значения в `s2`
```

При этом изначально значения заполняются мусором, но можно задать их дефолтные значения:

```C++
struct S {
  int x = 7;
  double y = 0.3;
  char z = 'y';

  std::string f() { return "Hello, world!"; }
};

int main() {
  S s;
  std::cout << s.x << " " << s.y << " " << s.z << " " << s.f() << std::endl;  // вывод: "7 0.3 y"
}
```

Также, отдельно стоит подметить, что переменные в структуре описываются в фигурных скобках, а значит в отдельном скоупе.

Внутри структур/классов можно объявлять еще и другие структуры/классы (inner-class), и даже внутри функции можно!

```C++
struct S {
  int x;
  struct SS {}; // ::S::SS
};

void f() {
  struct S {};
  S s;
  // s.x; // CE, используется локальная S без поля х
}

struct SS { // ::SS
  int y;
};

int main() {
  SS s;
  s.y; // OK, используется глобальная ::SS
  S::SS ss;
  s.y; // CE, используется SS из структуры S (::S::SS)
}
```

Если же мы хотим создать объект, но заполнить поля нам надо не дефолтными значениями,
то на такой случай существует **аггрегатная инициализация**.
**DISCLAIMER:** такая инициализация возможна только когда все поля явлются **публичными**. Что это значит? Узнаем чуть позже, пока можно воспринимать это как "работает только для структуры, не для класса".

```C++
struct S {
  int x = 3;
  double y;
  char c = 'c';
};

int main() {
  S s{1, 0.7, 'y'}; // инициализируем все поля в порядке их объявления в структуре
}
```

Как это работает: в каком порядке поля перечисляются при объявлении структуры (сверху вниз), в таком и надо указывать их значения.
При этом, можно не указывать последние n полей, тогда в качестве значений будут проставлены значениями по умолчанию:

```C++
int main() {
  S s{1, 0.7}; // c = 'c'
}
```

Еще полезная фишка: определение вне тела:

```C++
struct S {
  void f(); // здесь только объявление
};

// как определить вне тела
void S::f() { ... }
```

То есть мы как-будто как обычно определяем функции вне структуры, но добавляем перед индентификатором название структуры/класса.
Это бывает полезно в разных ситуациях. Например, объявление обычно оставляют в header файлах (.hpp, .h), а определение пишут в source файлах (.cpp, .cc), чтобы компиляция не занимала вечность

Кроме основных полей у любой структуры/класса есть константный указатель `this`, доступный внутри методов этого объекта и указывающий на сам объект.
Для любитилей питона: `this` — аналог `self`.
То есть тип этого объекта — `S* const`, где `S` — наша структура.
Данный указатель бывает полезен, когда у нас есть локальная переменная, которая "маскирует" какое-то поле, то есть имеет такое же название

```C++
struct S {
  int x = 5;
  void f(int x) {
    std::cout << x; // то, что передали в функцию
    std::cout << this->x; // поле структуры
  }
};
```

#### 2. Устройство в памяти

Посмотрим пример:

```C++
struct S {
  int x;
  double y;
  int c;
};
```
Вопрос к читателю: что выведет `sizeof(S)`?
<details>
  <summary> Ответ: </summary>
  24
</details>


Давайте разберемся, почему так.
Казалось бы, ну надо три переменные сохранить, две по 4 байта, одна 8 байт, итого 16. Но на самом деле, важен порядок объявления этих переменных.
Порядок определяется порядком упоминания в структуре (сверху вниз). Первый идет int — 4 байта.
Следующим идет double. Double требует, чтобы его адрес был кратен 8, а значит мы не можем положить его вплотную к int, требуется *padding* (отступ).
Соответственно это еще +4байта на отступ и +8байт на double. Следующий int кладется рядом, тут не нужен padding. Но после него так же будет padding, поэтому еще +4 байта
(логика в том, чтобы следующий объект в памяти положить по адресу кратному 8)
