# Лекция 9

## 3. Compound types

### 5. References (Ссылки)

#### 0. Мотивация

Можно сказать очень просто: указатели зло, хочется что-то удобнее в обращении, хотим создавать объект, *ссылающийся* на другой, без создания копии

#### 1. Базовый синтаксис

```C++
std::vector<int> v{1, 2, 3};
std::vector<int>& v2 = v;
```

`v2` — это **ссылка** на объект `v`. С момента создания она будет (почти) всегда вести себя как объект `v`, в частности `&v2 == &v1` и
`void f(vector<int>&)` не является перегрузкой функции `void f(vector<int>)`
(будет СЕ, если написать оба варианта).
Почему почти? — есть способ различить эти два объекта (`decltype`), но об этом мы поговорим потом

При объявлении ссылки её **необходимо** **проинициализировать** через lvalue. Поменять объект, на который она ссылается нельзя

#### 2. Что позволяет делать ссылка?

```C++
int& f(int& x, int n = 1) {
    x += n;
    return x;
}

int a = 7;
f(a); // a == 8
f(a) = 20; // a == 20
++f(a) = 0; // a = 0
```

А главное, мы можем еще раз усовершенствовать наш `swap`=)

```C++
void swap(int& x, int& y) {
    int tmp = x; // создаем копию
    x = y;
    y = tmp;
}
```

#### 3. Dangling reference

Рассмотрим следующий код
(по сути взяли функцию выше, но ошиблись в сигнатуре и забыли `&`):

```C++
int& g(int x) {
    ++x;
    return x;
}

int main() {
    int a = 7;
    g(7) = 10; // а всё, UB
}
```

Откуда здесь UB? Всё просто. Мы возвращаемся ссылку на инт. А что за объект, на который мы ссылаемся? — Да это же локальная (для функции `g`) переменная `x`.
То есть мы ссылаемся на объект, который после завершения вызова `g(7)` должен вообще-то разрушится

**Важно:** объект уничтожается, когда должен разрушиться его первоначальный экземпляр, без учета ссылок на него
