# Лекция 2

## 2. Введение в язык

### 1. Объявление и определение (declaration vs definition)

В первом приближении, можно сказать, что код на С++ -- это последовательность объявлений каких-то сущностей. Что это могут быть за сущности? Например:

```C++
type id; // переменная
type id = init; // переменная с инициализацией

// свои типы
struct S;
class S;
union U;

namespace N {}

// aliases
typedef shortcut long_name; 
```

***Замечание***: элиясы надо использовать осторожно!  `typedef vi std::vector<int>` мы **не используем** :) 

Полный список можно посмотреть [тут](https://en.cppreference.com/w/cpp/language/declarations#:~:text=Declarations%20are%20how%20names%20are,entity%20identified%20by%20the%20name.)

Более формально, объявление -- это представление программе сущности, в результате которого компилятор узнает необходимую ему информацию (типы, размеры и т.д.). Определение -- это такой вид объявления, при котором дополнительно в памяти резервируется необходимое место под объект (объявление, которого достаточно, чтобы использовать объект в программе).

Разница на примере функций:

```C++
int f();       // объявляется, но не определяется - ещё
int f() { }    // определяет функцию
```

**! ONE DEFINITION RULE:** каждая сущность должна быть определена не более одного раза. Объявлять при этом можно любое количество раз. 

***Замечание:*** объявление без определения -- UB

### 2. Область видимости имен

Каждое имя, которое появляется в программе на  C++, видно только в некоторой, возможно, прерывистой части исходного кода, называемой его областью видимости.

Самый высокий уровень -- *глобальный*, в котором можно выделять меньшие *локальные* уровни.

Каждый блок кода, выделенный в фигурных скобках создает свою область видимости:

```C++
#include <iostream>

// global scope

int x = 1;

namespace N {
    // именованная область видимости
    // Доступ к объектам: N::
    int x = 2; // N::x;
}

int main() {
    int x = 3;
    std::cout << x; // 3
    std::cout << N::x; // 2
    std::cout << ::x; // 1
    {
        // новый локальный scope без имени
        int x = 4;
        std::cout << x; // 4
    }
}
```

Неймспейсы можно открывать в глобальном скоупе или же внутри других неймспейсов

**unqualified-id** -- просто имя объекта

**qualified-id** -- обращение к объекту по полному имени, то есть с префиксом неймспейсов

#### using

`using namespace N` -- добавляет в текущую зону видимости другую область по её имени. Но так делать **плохо** по большинству стандартов (потому что зачем нам лишнее и легко получить колизию имен).

`using std::cout` -- добавляет конкретную сущность (OK)

Также **using** можно использовать для переименования:

```C++
    using Sec = int;
    Sec seconds = 5; // эквивалентно: int seconds = 5;
```

### 3. Основные типы

#### 0. Общая информация

C++ -- статически типизированный язык

***Статическая типизация*** — приём, широко используемый в языках программирования, при котором переменная, параметр подпрограммы, возвращаемое значение функции связывается с типом в момент объявления и тип не может быть изменён позже (переменная или параметр будут принимать, а функция — возвращать значения только этого типа).

***Динамическая типизация*** — приём, используемый в языках программирования и языках спецификации, при котором переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной. Таким образом, в различных участках программы одна и та же переменная может принимать значения разных типов.

Также С++ является примером языка со [слабой типизацией](https://ru.wikipedia.org/wiki/Сильная_и_слабая_типизация)

#### 1. Целочисленные 

```C++
short      // usually 2 bytes
int        // usually 4 bytes: [-2^31; 2^31)
long       // usually 4 bytes
long long  // usually 8 bytes
```

ключевое слово `unsigned` сдвигает диапозон, чтобы он начинался с нуля, например, `unsigned int` имеет диапозон [0; 2^32)

Есть еще и такая жуть:

```C++
int32_t
int64_t
int128_t
uint32_t
uint64_t
```

Отдельного внимания заслуживает `size_t`

#### 2. Вещественные типы

```C++
float        // usually 4 bytes
double       // usually 8 bytes | стандарт в С++
long double  // 8 or 16 bytes
```

Устройство этих типов: https://en.wikipedia.org/wiki/Double-precision_floating-point_format

#### 3. Символы

По сути, `char` это однобайтовое целое число (может быть как знаковое, так и беззнаковое)

```C++ 
char c = 'a'; // 'a' = 97
```

#### 4. Bool 

Значения: это `true` и `false`. Поддерживают операции логики 

Размер такой переменной -- **1 byte** (важно, что не 1 бит)

### 4. Основные операции над базовыми типами

#### 1. Внутри одного типа

* арифметические операции (+, -, *, /, %)
* побитовые операции (&, |, ^, <<, >>, ~)
* логические операции (&&, ||, !)

***Замечание:*** если в результате операции значение выходит за пределы установленного диапозона значений, то случается **переполнение** типа. В таком случае поведение бывает различным:

* в случае беззнаковых типов вычисления происходят по модулю длины диапозоны
* в случае знаковых типов такая программа считается неправильной и ошибочной (UB)

